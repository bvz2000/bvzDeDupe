#! /usr/bin/env python3

import datetime
import os.path
import sys

from bvzcomparedirs.comparesession import Session
from bvzdisplaylib import displaylib as displaylib

from src.parsercompare import Parser

DELIMITER = "@COMPAREFOLDERS@"


# ----------------------------------------------------------------------------------------------------------------------
def display_errors(scan_obj,
                   scan_type_name):
    """
    Displays the errors that have occurred during scans.

    :param scan_obj: The scan object that incurred the errors.
    :param scan_type_name:  The name of the scan directory. Should be either "canonical" or "query"

    :return: Nothing.
    """

    msg = f"{{BRIGHT_RED}}There have been errors scanning the {scan_type_name} directory. The compare operation "
    msg += "cannot be run until these errors have been addressed."
    displaylib.display_message(msg)
    result = displaylib.multiple_choice_user_input("Do you want to list the errors now? Or just quit?",
                                                   legal_answers=["L", "Q"],
                                                   alternate_legal_answers={"LIST": "L", "QUIT": "Q"})

    if result in {"Q"}:
        sys.exit(0)

    count = len(scan_obj.dir_permission_err_files)
    displaylib.display_message("\n\n")
    msg = f"{{BRIGHT_YELLOW}}DIRECTORIES WITH PERMISSION ERRORS:{{COLOR_NONE}}"
    msg += f"  ({{BRIGHT_RED}}{count}{{COLOR_NONE}} Errors)"
    displaylib.display_message(msg)
    displaylib.display_message("=" * 80)
    for err_file in scan_obj.dir_permission_err_files:
        displaylib.display_message(err_file)

    count = len(scan_obj.dir_permission_err_files)
    displaylib.display_message("\n\n")
    msg = f"{{BRIGHT_YELLOW}}DIRECTORIES WITH UNDEFINED ERRORS:{{COLOR_NONE}}"
    msg += f"  ({{BRIGHT_RED}}{count}{{COLOR_NONE}} Errors)"
    displaylib.display_message(msg)
    displaylib.display_message("=" * 80)
    for err_file in scan_obj.dir_generic_err_files:
        displaylib.display_message(err_file)

    count = len(scan_obj.file_permission_err_files)
    displaylib.display_message("\n\n")
    msg = f"{{BRIGHT_YELLOW}}FILES WITH PERMISSION ERRORS:{{COLOR_NONE}}"
    msg += f"  ({{BRIGHT_RED}}{count}{{COLOR_NONE}} Errors)"
    displaylib.display_message(msg)
    displaylib.display_message("=" * 80)
    for err_file in scan_obj.file_permission_err_files:
        displaylib.display_message(err_file)

    count = len(scan_obj.file_permission_err_files)
    displaylib.display_message("\n\n")
    msg = f"{{BRIGHT_YELLOW}}FILES WITH UNDEFINED ERRORS:{{COLOR_NONE}}"
    msg += f"  ({{BRIGHT_RED}}{count}{{COLOR_NONE}} Errors)"
    displaylib.display_message(msg)
    displaylib.display_message("=" * 80)
    for err_file in scan_obj.file_generic_err_files:
        displaylib.display_message(err_file)

    count = len(scan_obj.file_not_found_err_files)
    displaylib.display_message("\n\n")
    msg = f"{{BRIGHT_YELLOW}}FILES WITH FILE NOT FOUND ERRORS:{{COLOR_NONE}}"
    msg += f"  ({{BRIGHT_RED}}{count}{{COLOR_NONE}} Errors)"
    displaylib.display_message(msg)
    displaylib.display_message("=" * 80)
    for err_file in scan_obj.file_not_found_err_files:
        displaylib.display_message(err_file)

    sys.exit(0)


# ----------------------------------------------------------------------------------------------------------------------
def display_scan_results(scan_obj,
                         start_time):
    """
    Displays the scan results.

    :param scan_obj: The scan object that incurred the errors.
    :param start_time: The date-time object that holds the scan start time.

    :return: Nothing.
    """

    displaylib.display_message(f"Number of files scanned: {{BRIGHT_RED}}{scan_obj.checked_count}")
    if scan_obj.error_count == 0:
        displaylib.display_message(f"Number of errors: {{BRIGHT_RED}}{scan_obj.error_count}")
    else:
        displaylib.display_message(f"Number of errors: {{BG_RED}}{{BLINK}}{scan_obj.error_count}")
    displaylib.display_message(f"Number of links skipped: {{BRIGHT_RED}}{scan_obj.skipped_links}")
    displaylib.display_message(f"Number of zero length files skipped: {{BRIGHT_RED}}{scan_obj.skipped_zero_len}")
    displaylib.display_message(f"Number of hidden files skipped: {{BRIGHT_RED}}{scan_obj.skipped_hidden}")
    msg = f"{{BRIGHT_RED}}{scan_obj.skipped_include}"
    displaylib.display_message(f"Number of files skipped because they were outside of the inclusion regex's: {msg}")
    msg = f"{{BRIGHT_RED}}{scan_obj.skipped_exclude}"
    displaylib.display_message(f"Number of files skipped because they matched the exclusion regex's: {msg}")
    displaylib.display_message(f"Number of files accumulated: {{BRIGHT_RED}}{scan_obj.initial_count}")
    diff = datetime.datetime.now() - start_time
    delta = str(datetime.timedelta(seconds=diff.seconds))
    hours = f"{delta.split(':')[0]} hours"
    minutes = f"{delta.split(':')[1]} minutes"
    seconds = f"{delta.split(':')[2]} seconds"
    displaylib.display_message(f"Total scan time: {{BRIGHT_YELLOW}}{hours}, {minutes}, {seconds}")


# ----------------------------------------------------------------------------------------------------------------------
def do_scan(session_obj,
            scan_type_name,
            scan_type_is_query=True):
    """
    Scans the directory

    :param session_obj: The session object that manages the scans.
    :param scan_type_name: The name of the scan directory. Should be either "canonical" or "query"
    :param scan_type_is_query: If True, the scan type will be a query scan. Otherwise, it will be a canonical scan.

    :return: True if a scan is left to run to its end. False if the user interrupts it using ctrl-c
    """

    displaylib.display_message(f"\n\n{{BRIGHT_GREEN}}{scan_type_name.upper()} DIRECTORY")
    displaylib.display_message("=" * 80)

    try:
        if scan_type_is_query:
            try:
                for counter in session_obj.do_query_scan():
                    error_count = displaylib.format_string(f"{{BRIGHT_RED}}{session_obj.query_scan.error_count}")
                    displaylib.display_refreshable_message(f"Files scanned so far: {counter}   Errors: {error_count}")
            except IOError as e:
                displaylib.display_message(f"{{BRIGHT_RED}}ERROR:{{COLOR_NONE}} {str(e)}")
                sys.exit(1)

        else:
            try:
                for counter in session_obj.do_canonical_scan():
                    error_count = displaylib.format_string(f"{{BRIGHT_RED}}{session_obj.query_scan.error_count}")
                    displaylib.display_refreshable_message(f"Files scanned so far: {counter}   Errors: {error_count}")
            except IOError as e:
                displaylib.display_message(f"{{BRIGHT_RED}}ERROR:{{COLOR_NONE}} {str(e)}")
                sys.exit(1)
    except KeyboardInterrupt:
        return False

    displaylib.display_refreshable_message(" " * 80)
    displaylib.finish_refreshable_message()

    return True


# ----------------------------------------------------------------------------------------------------------------------
def main():

    parser_obj = Parser(sys.argv[1:])
    try:
        parser_obj.validate()
    except (FileNotFoundError, NotADirectoryError, PermissionError) as e:
        msg = f"{{RED}}Error:{{COLOR_NONE}} {e}"
        displaylib.display_message(msg)
        sys.exit(1)
    except FileExistsError as e:
        msg = f"{{YELLOW}}Warning:{{COLOR_NONE}} {e}"
        displaylib.display_message(msg)
        result = displaylib.multiple_choice_user_input("Overwrite file?",
                                                       legal_answers=["Y", "N"])
        if result in ["N"]:
            sys.exit(0)

    options = ""
    if parser_obj.args.match_on_name:
        options += "n"
    if parser_obj.args.match_on_parent:
        options += "p"
    if parser_obj.args.match_on_type:
        options += "t"
    if parser_obj.args.match_on_relpath:
        options += "r"
    if parser_obj.args.match_on_ctime:
        options += "c"
    if parser_obj.args.match_on_mtime:
        options += "m"

    session_obj = Session(query_dir=parser_obj.args.query_dir,
                          canonical_dir=parser_obj.args.canonical_dir,
                          skip_sub_dir=parser_obj.args.skip_sub_dir,
                          skip_hidden=not parser_obj.args.include_hidden,
                          skip_zero_len=not parser_obj.args.include_zero_length,
                          incl_dir_regex=parser_obj.args.incl_dir_regexes,
                          excl_dir_regex=parser_obj.args.excl_dir_regexes,
                          incl_file_regex=parser_obj.args.incl_file_regexes,
                          excl_file_regex=parser_obj.args.excl_file_regexes,
                          report_frequency=10)

    # ------------------------------------------------------------------------------------------------------------------
    displaylib.display_message("\n\n{{BRIGHT_GREEN}}SUMMARY")
    displaylib.display_message("=" * 80)

    query_d = os.path.abspath(parser_obj.args.query_dir)
    canonical_d = os.path.abspath(parser_obj.args.canonical_dir)

    str_len = 38

    displaylib.display_message("Query directory:".rjust(str_len), f"{{BRIGHT_YELLOW}}{query_d}")
    displaylib.display_message(" Canonical directory:".rjust(str_len), f"{{BRIGHT_YELLOW}}{canonical_d}")

    if parser_obj.args.output_file is not None:
        output_file = os.path.abspath(parser_obj.args.output_file)
        output_file_display = f"{{BRIGHT_YELLOW}}{output_file}"
    else:
        output_file_display = "{{BRIGHT_RED}}NO OUTPUT LOG FILE. QUERY RESULTS WILL ONLY BE DISPLAYED ON SCREEN."

    displaylib.display_message("Output log:".rjust(str_len),
                               output_file_display)
    displaylib.display_message("Skip sub-directories:".rjust(str_len),
                               parser_obj.args.skip_sub_dir)
    displaylib.display_message("Skip hidden files:".rjust(str_len),
                               displaylib.format_boolean(not parser_obj.args.include_hidden))
    displaylib.display_message("Skip zero length files:".rjust(str_len),
                               displaylib.format_boolean(not parser_obj.args.include_zero_length))
    displaylib.display_message("Names must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_name))
    displaylib.display_message("File extensions must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_type))
    displaylib.display_message("Parent directory name must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_parent))
    displaylib.display_message("Relative paths must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_relpath))
    displaylib.display_message("Creation date and time must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_ctime))
    displaylib.display_message("Modification date and time must match:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.match_on_mtime))
    displaylib.display_message("Skip checksum:".rjust(str_len),
                               displaylib.format_boolean(parser_obj.args.skip_checksum))

    result = displaylib.multiple_choice_user_input("Do compare? Yes/No/Quit",
                                                   legal_answers=["Y", "N", "Q"],
                                                   alternate_legal_answers={"YES": "Y", "NO": "N", "QUIT": "Q"},
                                                   default="Y",
                                                   blank_lines=2)

    if result in {"Q", "N"}:
        sys.exit(0)

    # ----------------------------------------------------------------------------------------------------------------------
    then = datetime.datetime.now()
    user_did_not_interrupt = do_scan(session_obj, "query", True)
    if user_did_not_interrupt:
        display_scan_results(session_obj.query_scan, then)
    if session_obj.query_scan.error_count > 0:
        display_errors(session_obj.query_scan, "query")
    if not user_did_not_interrupt:
        sys.exit(0)

    # ----------------------------------------------------------------------------------------------------------------------
    then = datetime.datetime.now()
    user_did_not_interrupt = do_scan(session_obj, "canonical", False)
    if user_did_not_interrupt:
        display_scan_results(session_obj.canonical_scan, then)
    if session_obj.canonical_scan.error_count > 0:
        display_errors(session_obj.canonical_scan, "canonical")
    if not user_did_not_interrupt:
        sys.exit(0)

    # ----------------------------------------------------------------------------------------------------------------------
    displaylib.display_message("\n\n{{BRIGHT_YELLOW}}COMPARING FILES:")
    displaylib.display_message("=" * 80)

    old_percent = 0
    then = datetime.datetime.now()
    for count in session_obj.do_compare(name=parser_obj.args.match_on_name,
                                        file_type=parser_obj.args.match_on_type,
                                        parent=parser_obj.args.match_on_parent,
                                        rel_path=parser_obj.args.match_on_relpath,
                                        ctime=parser_obj.args.match_on_ctime,
                                        mtime=parser_obj.args.match_on_mtime,
                                        skip_checksum=parser_obj.args.skip_checksum):
        dupes_str = f"{{BRIGHT_RED}}D:{{COLOR_NONE}} {len(session_obj.actual_matches.keys())}"
        unique_str = f"{{BRIGHT_RED}}U:{{COLOR_NONE}} {len(session_obj.unique)}"
        error_str = f"{{BRIGHT_RED}}E:{{COLOR_NONE}} {len(session_obj.source_error_files)}"
        postpend_str = displaylib.format_string(f"  {dupes_str} {unique_str} {error_str}")
        old_percent = displaylib.display_progress(count=count,
                                                  total=len(session_obj.query_scan.files),
                                                  old_percent=old_percent,
                                                  width=44,
                                                  postpend_str=postpend_str)
    displaylib.display_message("\n")

    # ----------------------------------------------------------------------------------------------------------------------
    displaylib.display_message("\n\n{{BRIGHT_GREEN}}RESULTS:")
    displaylib.display_message("=" * 80)

    num_files_checked = f"{{BRIGHT_RED}}{len(session_obj.query_scan.files)}"
    num_duplicates = f"{{BRIGHT_RED}}{len(session_obj.actual_matches)}"
    num_unique = f"{{BRIGHT_RED}}{len(session_obj.unique)}"
    num_reused_checksum = f"{{BRIGHT_RED}}{session_obj.pre_computed_checksum_count}"
    num_self = f"{{BRIGHT_RED}}{len(session_obj.skipped_self)}"

    displaylib.display_message(f"Number of files checked: {num_files_checked}")
    displaylib.display_message(f"Number of query files that are duplicates of canonical files: {num_duplicates}")
    displaylib.display_message(f"Number of query files that have no duplicates in canonical dir: {num_unique}")
    displaylib.display_message(f"Number of times a file was compared with itself: {num_self}")
    if not parser_obj.args.skip_checksum:
        displaylib.display_message(f"Number of times a checksum was reused: {num_reused_checksum}")
    diff = datetime.datetime.now() - then
    delta = str(datetime.timedelta(seconds=diff.seconds))
    hours = f"{delta.split(':')[0]} hours"
    minutes = f"{delta.split(':')[1]} minutes"
    seconds = f"{delta.split(':')[2]} seconds"
    displaylib.display_message(f"Total compare time: {{BRIGHT_YELLOW}}{hours}, {minutes}, {seconds}")

    if parser_obj.args.output_file:
        with open(parser_obj.args.output_file, "w") as f:
            f.write(f"{options}\n")
            f.write(f"{query_d}\n")
            f.write(f"{canonical_d}\n")
            f.write(f"{len(session_obj.actual_matches.items())}\n")
            for file_path, matches in session_obj.actual_matches.items():
                output = list()
                output.append("D")
                output.append(file_path)
                for match in matches:
                    output.append(match)
                f.write(f"{DELIMITER.join(output)}\n")
            for file_path in session_obj.unique:
                output = list()
                output.append("U")
                output.append(file_path)
                f.write(f"{DELIMITER.join(output)}\n")
            for file_path in session_obj.source_error_files:
                output = list()
                output.append("SE")
                output.append(file_path)
                f.write(f"{DELIMITER.join(output)}\n")
            for file_path in session_obj.possible_match_error_files:
                output = list()
                output.append("PME")
                output.append(file_path)
                f.write(f"{DELIMITER.join(output)}\n")

    matching = "{{BRIGHT_YELLOW}}M{{COLOR_NONE}}atching files"
    unique = "{{BRIGHT_YELLOW}}U{{COLOR_NONE}}nique files"
    both = "{{BRIGHT_YELLOW}}B{{COLOR_NONE}}oth"
    quitapp = "{{BRIGHT_YELLOW}}Q{{COLOR_NONE}}uit"
    prompt = displaylib.format_string(f"Display the {matching}, {unique}, {both}, or {quitapp}?")
    result = displaylib.multiple_choice_user_input(prompt,
                                                   legal_answers=["M", "U", "B", "Q"],
                                                   default="B",
                                                   blank_lines=2)
    if result in {"Q"}:
        sys.exit(0)

    if result in {"M", "B"}:
        displaylib.display_message("\n\n{{BRIGHT_GREEN}}MATCHES")
        displaylib.display_message("=" * 80)

        for file_path, matches in session_obj.actual_matches.items():
            displaylib.display_message(file_path)
            for match in matches:
                displaylib.display_message(f"{{BRIGHT_CYAN}}{match}")
            displaylib.display_message("\n\n")

    if result in {"U", "B"}:
        displaylib.display_message("\n\n{{BRIGHT_RED}}FILES IN QUERY DIR THAT HAVE NO DUPLICATES IN CANONICAL DIR")
        displaylib.display_message("=" * 80)

        for file_path in session_obj.unique:
            displaylib.display_message(file_path)


main()
